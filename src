local tween_service = game:GetService("TweenService")
local uis = game:GetService("UserInputService")
local run = game:GetService("RunService")
local text_service = game:GetService("TextService")
local players = game:GetService("Players")
local lp = players.LocalPlayer

local Library = {}
Library.__index = Library
Library.Commands = {}

function Library.new(name, autoConfig)
	local self = setmetatable({}, Library)
	self.Name = name or "UI Lib"
	self.AutoConfig = autoConfig
	self.StartTime = tick()
	self.ScreenGui = nil
	self.NotificationContainer = nil
	self.CmdBarFrame = nil
	self.CommandListHolder = nil
	self.CommandListFrame = nil
	self.CLShadow = nil
	self.CLScale = nil
	self.ScrollingFrame = nil
	self.Prefix = ">"
	self.ToggleKey = Enum.KeyCode.Semicolon
	return self
end

function Library:Init()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ZeeAdminUI"
	screenGui.ResetOnSpawn = false
	screenGui.DisplayOrder = 10000
	
	pcall(function()
		if gethui then
			screenGui.Parent = gethui()
		elseif syn and syn.protect_gui then
			syn.protect_gui(screenGui)
			screenGui.Parent = game:GetService("CoreGui")
		elseif game:GetService("CoreGui") then
			screenGui.Parent = game:GetService("CoreGui")
		else
			screenGui.Parent = lp:WaitForChild("PlayerGui")
		end
	end)
	
	if not screenGui.Parent then
		screenGui.Parent = lp:WaitForChild("PlayerGui")
	end
	
	self.ScreenGui = screenGui
	
	local NotificationContainer = Instance.new("Frame")
	NotificationContainer.Name = "NotificationContainer"
	NotificationContainer.Size = UDim2.new(0, 250, 1, 0)
	NotificationContainer.Position = UDim2.new(0, 20, 0, 80)
	NotificationContainer.BackgroundTransparency = 1
	NotificationContainer.Parent = screenGui
	
	local NotificationLayout = Instance.new("UIListLayout")
	NotificationLayout.Parent = NotificationContainer
	NotificationLayout.SortOrder = Enum.SortOrder.LayoutOrder
	NotificationLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	NotificationLayout.Padding = UDim.new(0, 10)
	
	self.NotificationContainer = NotificationContainer

	if self.AutoConfig then
		self:LoadConfig()
	end
	
	self:RegisterDefaultCommands()
	
	local loadTime = tick() - self.StartTime
	self:Notify(string.format("%s Loaded (%.2fs)", self.Name, loadTime), 5)
end

function Library:GetConfigPath()
	return self.Name .. "_config.json"
end

function Library:LoadConfig()
	if not isfile or not readfile or not isfile(self:GetConfigPath()) then return end
	
	local success, result = pcall(function()
		return game:GetService("HttpService"):JSONDecode(readfile(self:GetConfigPath()))
	end)
	
	if success and result then
		if result.Prefix then self.Prefix = result.Prefix end
		if result.ToggleKey then 
			local key = Enum.KeyCode[result.ToggleKey]
			if key then self.ToggleKey = key end
		end
	end
end

function Library:SaveConfig()
	if not writefile then return end
	
	local data = {
		Prefix = self.Prefix,
		ToggleKey = self.ToggleKey.Name
	}
	
	pcall(function()
		writefile(self:GetConfigPath(), game:GetService("HttpService"):JSONEncode(data))
	end)
end

function Library:RegisterDefaultCommands()
	self:AddCommand("cmds", "", "Show command list", function()
		self:ToggleCommandList(true)
	end)
	self:AddCommand("commands", "", "Show command list", function()
		self:ToggleCommandList(true)
	end)
	
	self:AddCommand("prefix", { {Name = "NewPrefix", Type = "Text"} }, "Change command prefix", function(newPrefix)
		if newPrefix and newPrefix ~= "" then
			self.Prefix = newPrefix
			if self.CmdBarFrame and self.CmdBarFrame:FindFirstChild("PromptLabel") then
				self.CmdBarFrame.PromptLabel.Text = newPrefix
			end
			
			self:Notify("Prefix set to " .. newPrefix)
			if self.AutoConfig then self:SaveConfig() end
		end
	end)
	
	self:AddCommand("rejoin", "", "Rejoin the server", function()
		if #players:GetPlayers() <= 1 then
			lp:Kick("\nRejoining...")
			task.wait()
			game:GetService("TeleportService"):Teleport(game.PlaceId, lp)
		else
			game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
		end
	end)
	
	self:AddCommand("serverhop", "", "Hop to a different server", function()
		local Http = game:GetService("HttpService")
		local TPS = game:GetService("TeleportService")
		local Api = "https://games.roblox.com/v1/games/"
		
		local _place = game.PlaceId
		local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"
		
		local function ListServers(cursor)
			local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
			return Http:JSONDecode(Raw)
		end
		
		local Server, Next; repeat
			local Servers = ListServers(Next)
			Server = Servers.data[1]
			Next = Servers.nextPageCursor
		until Server
		
		TPS:TeleportToPlaceInstance(_place, Server.id, lp)
	end)
	
	self:AddCommand("cls", "", "Clear client chat/console logs", function()
		if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then
		elseif game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents") then
		end
		print(string.rep("\n", 50))
		self:Notify("Console/Output cleared (locally)")
	end)
end

function Library:GetPlayers(targetStr)
	local players_list = {}
	targetStr = targetStr:lower()
	
	if targetStr == "all" then
		for _, v in pairs(players:GetPlayers()) do table.insert(players_list, v) end
	elseif targetStr == "others" then
		for _, v in pairs(players:GetPlayers()) do
			if v ~= lp then table.insert(players_list, v) end
		end
	elseif targetStr == "me" then
		table.insert(players_list, lp)
	elseif targetStr == "random" then
		local list = players:GetPlayers()
		if #list > 0 then table.insert(players_list, list[math.random(1, #list)]) end
	else
		for _, v in pairs(players:GetPlayers()) do
			if v.Name:lower():sub(1, #targetStr) == targetStr or v.DisplayName:lower():sub(1, #targetStr) == targetStr then
				table.insert(players_list, v)
			end
		end
	end
	
	return players_list
end

function Library:AddCommand(name, args, desc, callback)
	local argDisplay = ""
	local argData = {}
	
	if type(args) == "table" then
		argData = args
		for _, arg in ipairs(args) do
			argDisplay = argDisplay .. string.format("<%s> ", arg.Name or arg.Type)
		end
	else
		argDisplay = args or ""
	end
	
	local cmdData = {
		Name = name,
		ArgsDisplay = argDisplay,
		ArgData = argData,
		Desc = desc or "No description provided.",
		Callback = callback
	}
	
	table.insert(self.Commands, cmdData)
	
	if self.ScrollingFrame then
		self:PopulateCommandList()
	end
end

function Library:RunCommand(input)
	if input:sub(1, #self.Prefix) ~= self.Prefix then return end
	
	local cleanInput = input:sub(#self.Prefix + 1)
	local split = cleanInput:split(" ")
	local cmdName = split[1]:lower()
	table.remove(split, 1)
	
	local foundCmd
	for _, cmd in ipairs(self.Commands) do
		if cmd.Name:lower() == cmdName then
			foundCmd = cmd
			break
		end
	end
	
	if foundCmd then
		local parsedArgs = {}
		
		if #foundCmd.ArgData > 0 then
			for i, argDef in ipairs(foundCmd.ArgData) do
				local rawArg = split[i]
				
				if not rawArg and not argDef.Optional then
					self:Notify("Missing argument: " .. (argDef.Name or "Unknown"), 3)
					return
				end
				
				if rawArg then
					if argDef.Type == "Player" then
						local targets = self:GetPlayers(rawArg)
						if #targets == 0 then
							self:Notify("No matching players found for: " .. rawArg, 3)
							return
						end
						table.insert(parsedArgs, targets)
					elseif argDef.Type == "Number" then
						local num = tonumber(rawArg)
						if not num then
							self:Notify("Invalid number: " .. rawArg, 3)
							return
						end
						table.insert(parsedArgs, num)
					else
						if i == #foundCmd.ArgData and argDef.Type == "Text" then
							local rest = table.concat(split, " ", i)
							table.insert(parsedArgs, rest)
						else
							table.insert(parsedArgs, rawArg)
						end
					end
				else
					table.insert(parsedArgs, nil)
				end
			end
			
			task.spawn(function()
				local success, err = pcall(function()
					foundCmd.Callback(unpack(parsedArgs))
				end)
				if not success then
					warn("Command Error:", err)
					self:Notify("Error: " .. tostring(err), 5)
				end
			end)
		else
			task.spawn(function()
				local success, err = pcall(function()
					foundCmd.Callback(unpack(split))
				end)
				if not success then
					warn("Command Error:", err)
					self:Notify("Error: " .. tostring(err), 5)
				end
			end)
		end
	else
		self:Notify("Command not found: " .. cmdName, 2)
	end
end

function Library:Notify(text, duration)
	if not self.NotificationContainer then return end
	duration = duration or 3
	
	local Holder = Instance.new("Frame")
	Holder.BackgroundTransparency = 1
	Holder.Size = UDim2.new(1, 0, 0, 40)
	Holder.Parent = self.NotificationContainer
	
	local Inner = Instance.new("Frame")
	Inner.Size = UDim2.new(1, 0, 1, 0)
	Inner.Position = UDim2.new(-1.2, 0, 0, 0)
	Inner.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	Inner.BackgroundTransparency = 0.15
	Inner.BorderSizePixel = 0
	Inner.Parent = Holder
	
	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(0, 6)
	UICorner.Parent = Inner
	
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Transparency = 0.85
	UIStroke.Thickness = 1
	UIStroke.Parent = Inner
	
	local Shadow = Instance.new("ImageLabel")
	Shadow.Name = "Shadow"
	Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	Shadow.Position = UDim2.fromScale(0.5, 0.5)
	Shadow.Size = UDim2.new(1, 10, 1, 10)
	Shadow.BackgroundTransparency = 1
	Shadow.Image = "rbxassetid://1316045217"
	Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	Shadow.ImageTransparency = 0.6
	Shadow.SliceCenter = Rect.new(10, 10, 118, 118)
	Shadow.ScaleType = Enum.ScaleType.Slice
	Shadow.ZIndex = 0
	Shadow.Parent = Inner
	
	local Bar = Instance.new("Frame")
	Bar.Name = "AccentBar"
	Bar.Size = UDim2.new(0, 3, 0.6, 0)
	Bar.Position = UDim2.new(0, 6, 0.2, 0)
	Bar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Bar.BorderSizePixel = 0
	Bar.Parent = Inner
	
	local BarCorner = Instance.new("UICorner")
	BarCorner.CornerRadius = UDim.new(1, 0)
	BarCorner.Parent = Bar
	
	local Label = Instance.new("TextLabel")
	Label.Size = UDim2.new(1, -25, 1, 0)
	Label.Position = UDim2.new(0, 16, 0, 0)
	Label.BackgroundTransparency = 1
	Label.Text = text
	Label.TextColor3 = Color3.fromRGB(240, 240, 240)
	Label.TextSize = 14
	Label.Font = Enum.Font.GothamMedium
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.RichText = true
	Label.Parent = Inner
	
	local subject, status = text:match("^(.*)%s+(Enabled)$")
	if not subject then subject, status = text:match("^(.*)%s+(Disabled)$") end
	if not subject then subject, status = text:match("^(.*)%s+(Allowed)$") end
	if not subject then subject, status = text:match("^(.*)%s+(Disallowed)$") end
	
	if subject and status then
		local isGreen = (status == "Enabled" or status == "Allowed")
		local colorHex = isGreen and "#64ff64" or "#ff6464"
		Label.Text = string.format("<b>%s</b> <font color='%s'>%s</font>", subject, colorHex, status)
		Bar.BackgroundColor3 = isGreen and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
	else
		if text:lower():find("target") or text:lower():find("kill") or text:lower():find("stomp") then
			Bar.BackgroundColor3 = Color3.fromRGB(255, 150, 50)
		elseif text:lower():find("set to") then
			Bar.BackgroundColor3 = Color3.fromRGB(100, 200, 255)
		end
	end
	
	tween_service:Create(Inner, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	task.delay(duration, function()
		if not Inner.Parent then return end
		local tween = tween_service:Create(Inner, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
			Position = UDim2.new(-1.2, 0, 0, 0)
		})
		tween:Play()
		tween.Completed:Wait()
		Holder:Destroy()
	end)
end

function Library:CreateCommandBar(prefix)
	if self.Prefix == ">" and prefix then
		self.Prefix = prefix
	end
	
	local Backdrop = Instance.new("Frame")
	Backdrop.Name = "Backdrop"
	Backdrop.Size = UDim2.new(1, 0, 1, 0)
	Backdrop.BackgroundColor3 = Color3.new(0, 0, 0)
	Backdrop.BackgroundTransparency = 1
	Backdrop.Visible = false
	Backdrop.Parent = self.ScreenGui
	
	local CmdBarFrame = Instance.new("Frame")
	CmdBarFrame.Name = "CmdBarFrame"
	CmdBarFrame.Size = UDim2.new(0, 250, 0, 35)
	CmdBarFrame.AnchorPoint = Vector2.new(0.5, 0)
	CmdBarFrame.Position = UDim2.new(0.5, 0, 0.95, -46) 
	CmdBarFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	CmdBarFrame.BorderSizePixel = 0
	CmdBarFrame.BackgroundTransparency = 1
	CmdBarFrame.Parent = Backdrop
	
	local Shadow = Instance.new("ImageLabel")
	Shadow.Name = "Shadow"
	Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	Shadow.Position = UDim2.fromScale(0.5, 0.5)
	Shadow.Size = UDim2.new(1, 10, 1, 10)
	Shadow.BackgroundTransparency = 1
	Shadow.Image = "rbxassetid://1316045217"
	Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	Shadow.ImageTransparency = 1
	Shadow.ScaleType = Enum.ScaleType.Slice
	Shadow.SliceCenter = Rect.new(10, 10, 118, 118)
	Shadow.ZIndex = CmdBarFrame.ZIndex - 1
	Shadow.Parent = CmdBarFrame
	
	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(0, 6)
	UICorner.Parent = CmdBarFrame
	
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.fromRGB(80, 80, 80)
	UIStroke.Thickness = 1
	UIStroke.Transparency = 1
	UIStroke.Parent = CmdBarFrame
	
	local PromptLabel = Instance.new("TextLabel")
	PromptLabel.Name = "PromptLabel"
	PromptLabel.Size = UDim2.new(0, 20, 1, 0)
	PromptLabel.Position = UDim2.new(0, 10, 0, 0)
	PromptLabel.BackgroundTransparency = 1
	PromptLabel.Text = self.Prefix
	PromptLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
	PromptLabel.TextSize = 18
	PromptLabel.Font = Enum.Font.SourceSans
	PromptLabel.TextXAlignment = Enum.TextXAlignment.Center
	PromptLabel.Parent = CmdBarFrame
	
	local SuggestionLabel = Instance.new("TextLabel")
	SuggestionLabel.Name = "SuggestionLabel"
	SuggestionLabel.Size = UDim2.new(1, -40, 1, 0)
	SuggestionLabel.Position = UDim2.new(0, 35, 0, 0)
	SuggestionLabel.BackgroundTransparency = 1
	SuggestionLabel.Text = ""
	SuggestionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	SuggestionLabel.TextTransparency = 0.5
	SuggestionLabel.TextSize = 18
	SuggestionLabel.RichText = false
	SuggestionLabel.Font = Enum.Font.SourceSans
	SuggestionLabel.TextXAlignment = Enum.TextXAlignment.Left
	SuggestionLabel.Parent = CmdBarFrame
	
	local InputBox = Instance.new("TextBox")
	InputBox.Name = "InputBox"
	InputBox.Size = UDim2.new(1, -40, 1, 0)
	InputBox.Position = UDim2.new(0, 35, 0, 0)
	InputBox.BackgroundTransparency = 1
	InputBox.Text = ""
	InputBox.PlaceholderText = ""
	InputBox.TextColor3 = Color3.fromRGB(200, 200, 200)
	InputBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
	InputBox.TextSize = 18
	InputBox.Font = Enum.Font.SourceSans
	InputBox.TextXAlignment = Enum.TextXAlignment.Left
	InputBox.ClearTextOnFocus = false
	InputBox.Parent = CmdBarFrame
	
	self.CmdBarFrame = CmdBarFrame
	self.Backdrop = Backdrop
	self.InputBox = InputBox
	self.SuggestionLabel = SuggestionLabel
	
	local currentMatch = nil
	local currentSuggestionFull = ""
	local isVisible = false
	
	local function toggleCmdBar(state)
		if state ~= nil then isVisible = state else isVisible = not isVisible end
		
		if isVisible then
			Backdrop.Visible = true
			CmdBarFrame.Visible = true
			
			tween_service:Create(CmdBarFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
				BackgroundTransparency = 0.15,
				Position = UDim2.new(0.5, 0, 0.92, -46)
			}):Play()
			tween_service:Create(Shadow, TweenInfo.new(0.3), {ImageTransparency = 0.8}):Play()
			tween_service:Create(UIStroke, TweenInfo.new(0.3), {Transparency = 0}):Play()
			
			task.delay(0.1, function()
				if isVisible then
					InputBox.Text = ""
					InputBox:CaptureFocus()
				end
			end)
		else
			tween_service:Create(CmdBarFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
				BackgroundTransparency = 1,
				Position = UDim2.new(0.5, 0, 0.95, -46)
			}):Play()
			tween_service:Create(Shadow, TweenInfo.new(0.2), {ImageTransparency = 1}):Play()
			tween_service:Create(UIStroke, TweenInfo.new(0.2), {Transparency = 1}):Play()
			
			InputBox.Text = ""
			SuggestionLabel.Text = ""
			InputBox:ReleaseFocus()
			
			task.delay(0.2, function()
				if not isVisible then
					Backdrop.Visible = false
				end
			end)
		end
	end
	
	local function updateSuggestion()
		local text = InputBox.Text
		
		if text:find("\t") then
			text = text:gsub("\t", "")
			InputBox.Text = text
			InputBox.CursorPosition = #text + 1
		end
		
		SuggestionLabel.Text = ""
		currentMatch = nil
		currentSuggestionFull = ""
		
		if text == "" then return end
		
		local cleanText = text
		if cleanText:sub(1, #self.Prefix) == self.Prefix then
			cleanText = cleanText:sub(#self.Prefix + 1)
		end
		
		if cleanText == "" then return end
		
		local args = cleanText:split(" ")
		local cmdPart = args[1]:lower()
		
		if #args == 1 then
			for _, cmdData in ipairs(self.Commands) do
				if cmdData.Name:lower():sub(1, #cmdPart) == cmdPart then
					currentMatch = cmdData.Name
					local suffix = cmdData.Name:sub(#cmdPart + 1)
					currentSuggestionFull = text .. suffix
					
					local measureText = text:gsub(" ", "\194\160")
					local size = text_service:GetTextSize(measureText, InputBox.TextSize, InputBox.Font, Vector2.new(10000, 100))
					
					SuggestionLabel.Text = suffix
					SuggestionLabel.Position = UDim2.new(0, 35 + size.X, 0, 0)
					return
				end
			end
		end
		
		if #args >= 2 then
			local foundCmd = nil
			for _, cmdData in ipairs(self.Commands) do
				if cmdData.Name:lower() == cmdPart then
					foundCmd = cmdData
					break
				end
			end
			
			if foundCmd and foundCmd.ArgData then
				local argIndex = #args - 1
				local argDef = foundCmd.ArgData[argIndex] or foundCmd.ArgData[#foundCmd.ArgData] 
				
				if argDef and argDef.Type == "Player" then
					local partialName = args[#args]
					if partialName == "" then return end
					
					local bestMatch = nil
					local matchText = nil
					
					for _, player in ipairs(players:GetPlayers()) do
						if player ~= lp then
							if player.DisplayName:lower():sub(1, #partialName) == partialName:lower() then
								bestMatch = player
								matchText = player.DisplayName
								break
							end
							if player.Name:lower():sub(1, #partialName) == partialName:lower() then
								bestMatch = player
								matchText = player.Name
								break
							end
						end
					end
					
					if bestMatch then
						currentMatch = matchText
						local suffix = matchText:sub(#partialName + 1)
						currentSuggestionFull = text .. suffix
						
						local measureText = text:gsub(" ", "\194\160")
						local size = text_service:GetTextSize(measureText, InputBox.TextSize, InputBox.Font, Vector2.new(10000, 100))
						
						SuggestionLabel.Text = suffix
						SuggestionLabel.Position = UDim2.new(0, 35 + size.X, 0, 0)
					end
				end
			end
		end
	end
	
	InputBox:GetPropertyChangedSignal("Text"):Connect(updateSuggestion)
	
	InputBox.FocusLost:Connect(function(enterPressed)
		if enterPressed then
			local text = InputBox.Text
			if text ~= "" then
				self:RunCommand(self.Prefix .. text)
				InputBox.Text = ""
				toggleCmdBar(false)
			end
		end
	end)
	
	uis.InputBegan:Connect(function(input, gpe)
		if input.KeyCode == self.ToggleKey and not gpe then
			toggleCmdBar()
		elseif isVisible and input.KeyCode == Enum.KeyCode.Tab then
			if currentMatch and currentSuggestionFull ~= "" then
				InputBox.Text = currentSuggestionFull
				InputBox.CursorPosition = #InputBox.Text + 1
				updateSuggestion()
				task.defer(function() InputBox:CaptureFocus() end)
			end
		end
	end)
	
	return InputBox, Backdrop
end

function Library:MakeDraggable(gui)
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	gui:SetAttribute("TargetPos", gui.Position)

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			gui:SetAttribute("TargetPos", startPos)
			
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	uis.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			local delta = input.Position - dragStart
			local target = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
			gui:SetAttribute("TargetPos", target)
		end
	end)
	
	task.spawn(function()
		while gui.Parent do
			local target = gui:GetAttribute("TargetPos")
			if target then
				gui.Position = gui.Position:Lerp(target, 0.08)
			end
			run.RenderStepped:Wait()
		end
	end)
end

function Library:CreateCommandList()
	local CommandListHolder = Instance.new("Frame")
	CommandListHolder.Name = "CommandListHolder"
	CommandListHolder.Size = UDim2.new(0, 400, 0, 320)
	CommandListHolder.Position = UDim2.new(0.5, 0, 0.5, 0)
	CommandListHolder.AnchorPoint = Vector2.new(0.5, 0.5)
	CommandListHolder.BackgroundTransparency = 1
	CommandListHolder.Visible = false
	CommandListHolder.Parent = self.ScreenGui
	
	self:MakeDraggable(CommandListHolder)
	
	local CLShadow = Instance.new("ImageLabel")
	CLShadow.Name = "Shadow"
	CLShadow.AnchorPoint = Vector2.new(0.5, 0.5)
	CLShadow.Position = UDim2.fromScale(0.5, 0.5)
	CLShadow.Size = UDim2.new(1, 10, 1, 10)
	CLShadow.BackgroundTransparency = 1
	CLShadow.Image = "rbxassetid://1316045217"
	CLShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	CLShadow.ImageTransparency = 1
	CLShadow.ScaleType = Enum.ScaleType.Slice
	CLShadow.SliceCenter = Rect.new(10, 10, 118, 118)
	CLShadow.ZIndex = 0
	CLShadow.Parent = CommandListHolder
	
	local CommandListFrame = Instance.new("CanvasGroup")
	CommandListFrame.Name = "CommandListFrame"
	CommandListFrame.Size = UDim2.new(1, 0, 1, 0)
	CommandListFrame.Position = UDim2.new(0, 0, 0, 0)
	CommandListFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	CommandListFrame.BackgroundTransparency = 0.15
	CommandListFrame.BorderSizePixel = 0
	CommandListFrame.GroupTransparency = 1
	CommandListFrame.Parent = CommandListHolder
	
	local CLScale = Instance.new("UIScale")
	CLScale.Parent = CommandListFrame
	
	local CLCorner = Instance.new("UICorner")
	CLCorner.CornerRadius = UDim.new(0, 12)
	CLCorner.Parent = CommandListFrame
	
	local CLStroke = Instance.new("UIStroke")
	CLStroke.Color = Color3.fromRGB(80, 80, 80)
	CLStroke.Thickness = 1
	CLStroke.Parent = CommandListFrame
	
	local CLTitle = Instance.new("TextLabel")
	CLTitle.Size = UDim2.new(1, -40, 0, 30)
	CLTitle.Position = UDim2.new(0, 10, 0, 5)
	CLTitle.BackgroundTransparency = 1
	CLTitle.Text = "Commands"
	CLTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	CLTitle.TextTransparency = 0.3
	CLTitle.TextSize = 20
	CLTitle.Font = Enum.Font.GothamSemibold
	CLTitle.TextXAlignment = Enum.TextXAlignment.Left
	CLTitle.Parent = CommandListFrame
	
	local CLClose = Instance.new("TextButton")
	CLClose.Size = UDim2.new(0, 20, 0, 20)
	CLClose.Position = UDim2.new(1, -25, 0, 8)
	CLClose.BackgroundTransparency = 1
	CLClose.Text = "X"
	CLClose.TextColor3 = Color3.fromRGB(200, 200, 200)
	CLClose.TextSize = 14
	CLClose.Font = Enum.Font.Gotham
	CLClose.Parent = CommandListFrame
	
	CLClose.MouseButton1Click:Connect(function()
		self:ToggleCommandList(false)
	end)
	
	local ScrollingFrame = Instance.new("ScrollingFrame")
	ScrollingFrame.Size = UDim2.new(1, -20, 1, -50)
	ScrollingFrame.Position = UDim2.new(0, 10, 0, 40)
	ScrollingFrame.BackgroundTransparency = 1
	ScrollingFrame.BorderSizePixel = 0
	ScrollingFrame.ScrollBarThickness = 4
	ScrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 80)
	ScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	ScrollingFrame.Parent = CommandListFrame
	
	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.Padding = UDim.new(0, 5)
	UIListLayout.Parent = ScrollingFrame
	
	local UIPadding = Instance.new("UIPadding")
	UIPadding.PaddingTop = UDim.new(0, 5)
	UIPadding.PaddingLeft = UDim.new(0, 2)
	UIPadding.Parent = ScrollingFrame
	
	local CLSearchFrame = Instance.new("Frame")
	CLSearchFrame.Name = "SearchFrame"
	CLSearchFrame.LayoutOrder = -1
	CLSearchFrame.Size = UDim2.new(1, -10, 0, 20)
	CLSearchFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	CLSearchFrame.BackgroundTransparency = 0.5
	CLSearchFrame.BorderSizePixel = 0
	CLSearchFrame.Parent = ScrollingFrame
	
	local CLSearchCorner = Instance.new("UICorner")
	CLSearchCorner.CornerRadius = UDim.new(0, 6)
	CLSearchCorner.Parent = CLSearchFrame
	
	local CLSearchStroke = Instance.new("UIStroke")
	CLSearchStroke.Color = Color3.fromRGB(60, 60, 60)
	CLSearchStroke.Thickness = 1
	CLSearchStroke.Parent = CLSearchFrame
	
	local CLSearchInput = Instance.new("TextBox")
	CLSearchInput.Name = "Input"
	CLSearchInput.Size = UDim2.new(1, -10, 1, 0)
	CLSearchInput.Position = UDim2.new(0, 10, 0, 0)
	CLSearchInput.BackgroundTransparency = 1
	CLSearchInput.Text = ""
	CLSearchInput.PlaceholderText = "Search commands..."
	CLSearchInput.TextColor3 = Color3.fromRGB(220, 220, 220)
	CLSearchInput.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
	CLSearchInput.TextSize = 12
	CLSearchInput.Font = Enum.Font.Gotham
	CLSearchInput.TextXAlignment = Enum.TextXAlignment.Left
	CLSearchInput.Parent = CLSearchFrame
	
	self.CommandListHolder = CommandListHolder
	self.CommandListFrame = CommandListFrame
	self.CLShadow = CLShadow
	self.CLScale = CLScale
	self.ScrollingFrame = ScrollingFrame
	self.CLSearchInput = CLSearchInput
	
	CLSearchInput:GetPropertyChangedSignal("Text"):Connect(function()
		local query = CLSearchInput.Text:lower()
		for _, child in ipairs(ScrollingFrame:GetChildren()) do
			if child:IsA("Frame") and child.Name ~= "SearchFrame" then
				if child.Name:lower():find(query) then
					child.Visible = true
				else
					child.Visible = false
				end
			end
		end
	end)
	
	self:PopulateCommandList()
end

function Library:PopulateCommandList()
	if not self.ScrollingFrame then return end
	
	for _, child in ipairs(self.ScrollingFrame:GetChildren()) do
		if child:IsA("Frame") and child.Name ~= "SearchFrame" then 
			child:Destroy() 
		end
	end
	
	for _, cmd in ipairs(self.Commands) do
		local entry = Instance.new("Frame")
		entry.Name = cmd.Name
		entry.Size = UDim2.new(1, 0, 0, 40)
		entry.BackgroundTransparency = 1
		entry.Parent = self.ScrollingFrame
		
		local interactBtn = Instance.new("TextButton")
		interactBtn.Name = "InteractBtn"
		interactBtn.Size = UDim2.new(1, 0, 1, 0)
		interactBtn.BackgroundTransparency = 1
		interactBtn.Text = ""
		interactBtn.Parent = entry
		
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Name = "CmdName"
		nameLabel.Size = UDim2.new(1, 0, 0, 20)
		nameLabel.Position = UDim2.new(0, 0, 0, 5)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = string.format("%s%s", self.Prefix, cmd.Name)
		nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		nameLabel.TextTransparency = 0.1
		nameLabel.TextSize = 16
		nameLabel.Font = Enum.Font.GothamMedium
		nameLabel.TextXAlignment = Enum.TextXAlignment.Left
		nameLabel.Parent = entry
		
		local descLabel = Instance.new("TextLabel")
		descLabel.Name = "CmdDesc"
		descLabel.Size = UDim2.new(1, 0, 0, 15)
		descLabel.Position = UDim2.new(0, 0, 0, 22)
		descLabel.BackgroundTransparency = 1
		
		local argText = cmd.ArgsDisplay or ""
		if argText ~= "" then
			descLabel.Text = string.format("%s - %s", argText, cmd.Desc)
		else
			descLabel.Text = cmd.Desc
		end
		
		descLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
		descLabel.TextTransparency = 0.4
		descLabel.TextSize = 12
		descLabel.Font = Enum.Font.Gotham
		descLabel.TextXAlignment = Enum.TextXAlignment.Left
		descLabel.Parent = entry
		
		interactBtn.MouseEnter:Connect(function()
			tween_service:Create(nameLabel, TweenInfo.new(0.2), {TextColor3 = Color3.fromRGB(100, 255, 100)}):Play()
		end)
		interactBtn.MouseLeave:Connect(function()
			tween_service:Create(nameLabel, TweenInfo.new(0.2), {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
		end)
		
		interactBtn.MouseButton1Click:Connect(function()
			if cmd.ArgData and #cmd.ArgData > 0 then
				if self.InputBox then
					self.InputBox.Text = cmd.Name .. " "
					self.InputBox:CaptureFocus()
					
					if self.Backdrop then self.Backdrop.Visible = true end
					
					self:ToggleCommandList(false)
				end
			else
				self:RunCommand(self.Prefix .. cmd.Name)
				
				tween_service:Create(nameLabel, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { TextTransparency = 0.5 }):Play()
				task.delay(0.1, function()
					tween_service:Create(nameLabel, TweenInfo.new(0.2), { TextTransparency = 0.1 }):Play()
				end)
			end
		end)
	end
end

function Library:ToggleCommandList(show)
	if show == nil then show = not self.CommandListHolder.Visible end
	
	if show then
		self.CommandListHolder.Visible = true
		if self.CommandListFrame.GroupTransparency >= 0.9 then
			self.CommandListFrame.GroupTransparency = 1
			self.CLShadow.ImageTransparency = 1
			self.CLScale.Scale = 0.9
		end
		
		tween_service:Create(self.CommandListFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			GroupTransparency = 0
		}):Play()
		tween_service:Create(self.CLShadow, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			ImageTransparency = 0.8
		}):Play()
		tween_service:Create(self.CLScale, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Scale = 1
		}):Play()
	else
		tween_service:Create(self.CommandListFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			GroupTransparency = 1
		}):Play()
		tween_service:Create(self.CLShadow, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			ImageTransparency = 1
		}):Play()
		tween_service:Create(self.CLScale, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Scale = 0.9
		}):Play()
		
		task.delay(0.2, function()
			if self.CommandListFrame.GroupTransparency >= 0.9 then
				self.CommandListHolder.Visible = false
			end
		end)
	end
end

return Library
